<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ± åƒç´ çŒ«å’ªè·‘é…·</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
background: #0a0a0f;
font-family: 'Microsoft YaHei', monospace;
overflow: hidden;
}
#gameContainer {
position: relative;
box-shadow: 0 0 50px rgba(0,0,0,0.8);
border-radius: 8px;
overflow: hidden;
}
#gameCanvas {
image-rendering: pixelated;
display: block;
}
#ui {
position: absolute;
top: 15px; left: 15px; right: 15px;
display: flex;
justify-content: space-between;
color: #fff;
font-size: 16px;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
pointer-events: none;
z-index: 10;
}
.ui-item {
background: rgba(0,0,0,0.5);
padding: 8px 15px;
border-radius: 20px;
border: 2px solid rgba(255,255,255,0.2);
}
.progress-bar {
position: absolute;
top: 60px;
left: 50%;
transform: translateX(-50%);
width: 200px;
height: 10px;
background: rgba(0,0,0,0.5);
border-radius: 5px;
overflow: hidden;
}
.progress-fill {
height: 100%;
background: linear-gradient(90deg, #f1c40f, #e74c3c);
transition: width 0.3s;
}
#levelInfo, #gameOver, #victory {
position: absolute;
top: 50%; left: 50%;
transform: translate(-50%, -50%);
text-align: center;
color: #fff;
display: none;
background: rgba(10,10,15,0.95);
padding: 40px 60px;
border-radius: 20px;
border: 3px solid;
z-index: 100;
}
#levelInfo { border-color: #f1c40f; }
#gameOver { border-color: #e74c3c; }
#victory { border-color: #2ecc71; }
.btn {
margin-top: 20px;
padding: 12px 30px;
font-size: 16px;
border: none;
color: #fff;
cursor: pointer;
border-radius: 25px;
background: linear-gradient(135deg, #667eea, #764ba2);
}
#instructions {
position: absolute;
bottom: 15px;
left: 50%;
transform: translateX(-50%);
color: rgba(255,255,255,0.6);
font-size: 12px;
text-align: center;
}
.key {
display: inline-block;
background: rgba(255,255,255,0.2);
padding: 2px 6px;
border-radius: 4px;
margin: 0 2px;
}
</style>
</head>
<body>
<div id="gameContainer">
<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="ui">
<div class="ui-item" id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
<div class="ui-item" id="level">ç¬¬ 1 å…³</div>
<div class="ui-item" id="score">ğŸ’° 0 / 10</div>
</div>
<div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>

<div id="levelInfo">
<h2 id="levelTitle">ç¬¬ 1 å…³</h2>
<p id="levelDesc">æ”¶é›† 10 ä¸ªé‡‘å¸</p>
<p style="font-size: 14px; color: #888; margin-top: 10px;">A/Dç§»åŠ¨ | ç©ºæ ¼/ç‚¹å‡»è·³è·ƒ</p>
<button class="btn" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
</div>

<div id="gameOver">
<h2>ğŸ’€ GAME OVER</h2>
<p>æœ€ç»ˆå…³å¡: <span id="finalLevel">1</span></p>
<p>æ€»é‡‘å¸: <span id="finalCoins">0</span></p>
<button class="btn" id="restartBtn">é‡æ–°å¼€å§‹</button>
</div>

<div id="victory">
<h2>ğŸ† é€šå…³æˆåŠŸ!</h2>
<p>æ­å–œå®Œæˆæ‰€æœ‰å…³å¡!</p>
<p>æ€»é‡‘å¸: <span id="totalCoins">0</span></p>
<button class="btn" id="playAgainBtn">å†ç©ä¸€æ¬¡</button>
</div>

<div id="instructions">
<span class="key">A</span>/<span class="key">D</span> ç§»åŠ¨ | 
<span class="key">ç©ºæ ¼</span> è·³è·ƒ | 
<span class="key">ç‚¹å‡»</span> è·³è·ƒ
</div>
</div>

<script>
// ==================== æ¸¸æˆé…ç½® ====================
const CANVAS_WIDTH = 900;
const CANVAS_HEIGHT = 500;
const GROUND_Y = 370;

// ==================== å…³å¡é…ç½® ====================
const LEVELS = [
{ id: 1, targetCoins: 10, obstacleRate: 0.015, monsterCount: 0, speed: 3 },
{ id: 2, targetCoins: 30, obstacleRate: 0.022, monsterCount: 1, speed: 3.5 },
{ id: 3, targetCoins: 50, obstacleRate: 0.028, monsterCount: 3, speed: 4 }
];

// ==================== æ¸¸æˆçŠ¶æ€ ====================
let currentLevel = 0;
let lives = 3;
let coins = 0;
let gameRunning = false;
let frameCount = 0;

// ==================== Canvas ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// ==================== è¾“å…¥ ====================
const keys = {};
document.addEventListener('keydown', (e) => {
keys[e.key.toLowerCase()] = true;
if (e.code === 'Space') { e.preventDefault(); cat.jump(); }
});
document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
canvas.addEventListener('click', () => cat.jump());
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); cat.jump(); });

// ==================== AABBç¢°æ’æ£€æµ‹ ====================
function checkCollision(rect1, rect2) {
return rect1.x < rect2.x + rect2.width &&
rect1.x + rect1.width > rect2.x &&
rect1.y < rect2.y + rect2.height &&
rect1.y + rect1.height > rect2.y;
}

// ==================== ç²’å­ç³»ç»Ÿ ====================
class ParticleSystem {
constructor() {
this.particles = [];
}

create(x, y, color, count) {
for (let i = 0; i < count; i++) {
this.particles.push({
x: x, y: y,
vx: (Math.random() - 0.5) * 8,
vy: (Math.random() - 0.5) * 8,
life: 40, color: color,
size: Math.random() * 5 + 2
});
}
}

createText(x, y, text, color) {
this.particles.push({
x: x, y: y, text: text, color: color,
vy: -2, life: 40, isText: true
});
}

update() {
this.particles = this.particles.filter(p => {
p.x += p.vx; p.y += p.vy; p.life--;
return p.life > 0;
});
}

draw() {
this.particles.forEach(p => {
ctx.globalAlpha = p.life / 40;
if (p.isText) {
ctx.fillStyle = p.color;
ctx.font = 'bold 20px Arial';
ctx.fillText(p.text, p.x, p.y);
} else {
ctx.fillStyle = p.color;
ctx.beginPath();
ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
ctx.fill();
}
});
ctx.globalAlpha = 1;
}
}

const particles = new ParticleSystem();
// ==================== çŒ«å’ªç±» ====================

class Cat {

    constructor() {

        this.x = 120; this.y = GROUND_Y - 50;

        this.width = 50; this.height = 50;

        this.velocityY = 0; this.grounded = true;

        this.invincible = false; this.invincibleTime = 0;

        this.shieldTime = 0; this.animFrame = 0;

    }

    

    jump() {

        if (this.grounded) {

            this.velocityY = -14;

            this.grounded = false;

            particles.create(this.x + this.width/2, this.y + this.height, '#fff', 5);

        }

    }

    

    update() {

        this.animFrame++;

        const speed = 5;

        if (keys['a'] || keys['arrowleft']) this.x = Math.max(0, this.x - speed);

        if (keys['d'] || keys['arrowright']) this.x = Math.min(CANVAS_WIDTH - this.width, this.x + speed);

        

        this.velocityY += 0.6;

        this.y += this.velocityY;

        

        if (this.y + this.height >= GROUND_Y) {

            this.y = GROUND_Y - this.height;

            this.velocityY = 0;

            this.grounded = true;

        }

        

        if (this.invincible) {

            this.invincibleTime--;

            if (this.invincibleTime <= 0) this.invincible = false;

        }

        if (this.shieldTime > 0) this.shieldTime--;

    }

    

    takeDamage() {

        if (this.invincible || this.shieldTime > 0) return false;

        lives--;

        this.invincible = true;

        this.invincibleTime = 90;

        particles.create(this.x + this.width/2, this.y + this.height/2, '#ff4757', 15);

        return true;

    }

    

    heal() {

        if (lives < 3) {

            lives++;

            particles.createText(this.x + this.width/2, this.y, '+1â¤ï¸', '#2ecc71');

        }

    }

    

    draw() {

        if (this.invincible && Math.floor(Date.now() / 80) % 2 === 0) ctx.globalAlpha = 0.4;

        

        ctx.fillStyle = '#ff8c42';

        ctx.fillRect(this.x + 10, this.y + 15, 30, 28);

        ctx.fillRect(this.x + 20, this.y - 5, 28, 24);

        

        ctx.fillStyle = '#fff';

        ctx.beginPath(); ctx.ellipse(this.x + 28, this.y + 6, 6, 7, 0, 0, Math.PI * 2); ctx.fill();

        ctx.beginPath(); ctx.ellipse(this.x + 42, this.y + 6, 6, 7, 0, 0, Math.PI * 2); ctx.fill();

        

        ctx.fillStyle = '#2c3e50';

        ctx.beginPath(); ctx.ellipse(this.x + 28, this.y + 7, 3.5, 4.5, 0, 0, Math.PI * 2); ctx.fill();

        ctx.beginPath(); ctx.ellipse(this.x + 42, this.y + 7, 3.5, 4.5, 0, 0, Math.PI * 2); ctx.fill();

        

        if (this.shieldTime > 0) {

            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;

            ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);

        }

        ctx.globalAlpha = 1;

    }

}



// ==================== é‡‘å¸ç±» ====================

class Coin {

    constructor(x, y) {

        this.x = x; this.y = y; this.width = 30; this.height = 30;

        this.collected = false; this.rotation = 0;

        this.floatOffset = Math.random() * Math.PI * 2;

    }

    update() { this.x -= LEVELS[currentLevel].speed; this.rotation += 0.08; }

    draw() {

        const floatY = Math.sin(Date.now() * 0.005 + this.floatOffset) * 5;

        const scale = Math.abs(Math.cos(this.rotation));

        ctx.save();

        ctx.translate(this.x + 15, this.y + 15 + floatY);

        ctx.scale(scale, 1);

        ctx.fillStyle = '#f1c40f';

        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = '#f39c12';

        ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = '#f1c40f';

        ctx.font = 'bold 16px monospace'; ctx.textAlign = 'center';

        ctx.fillText('$', 0, 5);

        ctx.restore();

    }

}



// ==================== å°–åˆºç±» ====================

class Spike {

    constructor(x) {

        this.x = x; this.y = GROUND_Y - 35;

        this.width = 35; this.height = 35;

    }

    update() { this.x -= LEVELS[currentLevel].speed; }

    draw() {

        ctx.fillStyle = '#e74c3c';












       ctx.beginPath();

        ctx.moveTo(this.x, this.y + 35);

        ctx.lineTo(this.x + 17.5, this.y);

        ctx.lineTo(this.x + 35, this.y + 35);

        ctx.closePath(); ctx.fill();

    }

}



// ==================== ç®±å­ç±» ====================

class Box {

    constructor(x) {

        this.x = x; this.y = GROUND_Y - 45;

        this.width = 45; this.height = 45;

    }

    update() { this.x -= LEVELS[currentLevel].speed; }

    draw() {

        ctx.fillStyle = '#27ae60';

        ctx.fillRect(this.x, this.y, 45, 45);

        ctx.fillStyle = '#1e8449';

        ctx.fillRect(this.x, this.y, 45, 5);

        ctx.fillRect(this.x, this.y + 40, 45, 5);

        ctx.fillStyle = '#fff';

        ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';

        ctx.fillText('â†‘', this.x + 22.5, this.y + 30);

    }

}



// ==================== æ€ªç‰©ç±» ====================

class Monster {

    constructor(x) {

        this.x = x; this.y = GROUND_Y - 45;

        this.width = 45; this.height = 45;

        this.speed = 1.5; this.frame = 0;

    }

    update() {

        this.x -= LEVELS[currentLevel].speed + this.speed;

        this.frame++;

    }

    draw() {

        const bounce = Math.sin(this.frame * 0.3) * 3;

        ctx.fillStyle = '#e74c3c';

        ctx.fillRect(this.x + 5, this.y + 10 + bounce, 35, 30);

        ctx.fillStyle = '#fff';

        ctx.fillRect(this.x + 12, this.y + 15 + bounce, 8, 8);

        ctx.fillRect(this.x + 28, this.y + 15 + bounce, 8, 8);

        ctx.fillStyle = '#000';

        ctx.fillRect(this.x + 14, this.y + 17 + bounce, 4, 4);

        ctx.fillRect(this.x + 30, this.y + 17 + bounce, 4, 4);

    }

}
// ==================== æ¸¸æˆå¯¹è±¡ç®¡ç† ====================

const cat = new Cat();

let coins = [];

let spikes = [];

let boxes = [];

let monsters = [];



function spawnObjects() {

    const level = LEVELS[currentLevel];

    if (Math.random() < level.obstacleRate * 1.5) {

        coins.push(new Coin(CANVAS_WIDTH, GROUND_Y - 70 - Math.random() * 100));

    }

    if (Math.random() < level.obstacleRate * 0.6) {

        spikes.push(new Spike(CANVAS_WIDTH));

    }

    if (Math.random() < level.obstacleRate * 0.4) {

        boxes.push(new Box(CANVAS_WIDTH));

    }

    if (monsters.length < level.monsterCount && Math.random() < 0.005) {

        monsters.push(new Monster(CANVAS_WIDTH));

    }

}



// ==================== æ¸¸æˆé€»è¾‘ ====================

function update() {

    if (!gameRunning) return;

    frameCount++;

    

    cat.update();

    particles.update();

    

    spawnObjects();

    

    // æ›´æ–°é‡‘å¸

    coins = coins.filter(coin => {

        coin.update();

        if (!coin.collected && checkCollision(cat, coin)) {

            coin.collected = true;

            coins++;

            particles.create(coin.x + 15, coin.y + 15, '#f1c40f', 10);

            updateUI();

            checkLevelComplete();

            return false;

        }

        return coin.x > -50;

    });

    

    // æ›´æ–°å°–åˆº

    spikes = spikes.filter(spike => {

        spike.update();

        if (checkCollision(cat, spike)) cat.takeDamage();

        return spike.x > -50;

    });

    

    // æ›´æ–°ç®±å­

    boxes = boxes.filter(box => {

        box.update();

        if (cat.velocityY > 0 &&

            cat.x + cat.width > box.x + 5 &&

            cat.x < box.x + 40 &&

            cat.y + cat.height >= box.y &&

            cat.y + cat.height <= box.y + 15) {

            cat.y = box.y - cat.height;

            cat.velocityY = 0;

            cat.grounded = true;

            cat.shieldTime = 180;

        }

        return box.x > -50;

    });

    

    // æ›´æ–°æ€ªç‰©

    monsters = monsters.filter(monster => {

        monster.update();

        if (cat.velocityY > 0 &&

            cat.x + cat.width > monster.x + 5 &&

            cat.x < monster.x + 40 &&

            cat.y + cat.height >= monster.y &&

            cat.y + cat.height <= monster.y + 20) {

            cat.velocityY = -10;

            cat.heal();

            particles.create(monster.x + 22, monster.y + 22, '#ff6b6b', 12);

            return false;

        } else if (checkCollision(cat, monster)) {

            cat.takeDamage();

        }

        return monster.x > -100;

    });

}



function draw() {

    // èƒŒæ™¯

    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);

    grad.addColorStop(0, '#1a1a2e');

    grad.addColorStop(1, '#16213e');

    ctx.fillStyle = grad;

    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    

    // æ˜Ÿæ˜Ÿ

    ctx.fillStyle = '#fff';

    for (let i = 0; i < 50; i++) {

        const x = (i * 37 + frameCount * 0.1) % CANVAS_WIDTH;

        const y = (i * 23) % (CANVAS_HEIGHT * 0.6);

        ctx.globalAlpha = 0.3 + (Math.sin(frameCount * 0.05 + i) + 1) * 0.35;

        ctx.fillRect(x, y, (i % 3) + 1, (i % 3) + 1);

    }

    ctx.globalAlpha = 1;

    

    // åœ°é¢

    ctx.fillStyle = '#2ecc71';

    ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

    ctx.fillStyle = '#27ae60';

    for (let x = 0; x < CANVAS_WIDTH; x += 20) {

        ctx.fillRect(x - (frameCount % 20), GROUND_Y, 10, 5);

    } 

    // ç»˜åˆ¶å¯¹è±¡

    boxes.forEach(b => b.draw());

    spikes.forEach(s => s.draw());

    coins.forEach(c => c.draw());

    monsters.forEach(m => m.draw());

    cat.draw();

    particles.draw();

}

function updateUI() {

    const level = LEVELS[currentLevel];

    document.getElementById('lives').textContent = 'â¤ï¸'.repeat(lives);

    document.getElementById('level').textContent = `ç¬¬ ${currentLevel + 1} å…³`;

    document.getElementById('score').textContent = `ğŸ’° ${coins} / ${level.targetCoins}`;

    document.getElementById('progressFill').style.width = `${(coins / level.targetCoins) * 100}%`;

}

function checkLevelComplete() {

    const level = LEVELS[currentLevel];

    if (coins >= level.targetCoins) {

        if (currentLevel < LEVELS.length - 1) {

            nextLevel();

        } else {

            victory();

        }

    }

}

function nextLevel() {

    gameRunning = false;

    currentLevel++;

    coins = 0;

    lives = 3; // æ¢å¤3é¢—å¿ƒ

    cat.reset();

    coins = []; spikes = []; boxes = []; monsters = [];

    document.getElementById('levelTitle').textContent = `ç¬¬ ${currentLevel + 1} å…³`;

    document.getElementById('levelDesc').textContent = `æ”¶é›† ${LEVELS[currentLevel].targetCoins} ä¸ªé‡‘å¸`;

    document.getElementById('levelInfo').style.display = 'block';

    updateUI();

}



function gameOver() {

    gameRunning = false;

    document.getElementById('finalLevel').textContent = currentLevel + 1;

    document.getElementById('finalCoins').textContent = coins;

    document.getElementById('gameOver').style.display = 'block';

}



function victory() {

    gameRunning = false;

    document.getElementById('totalCoins').textContent = coins;

    document.getElementById('victory').style.display = 'block';

}



function startLevel() {

    document.getElementById('levelInfo').style.display = 'none';

    gameRunning = true;

}



function resetGame() {

    currentLevel = 0;

    lives = 3;

    coins = 0;

    cat.reset();

    coins = []; spikes = []; boxes = []; monsters = [];

    document.getElementById('gameOver').style.display = 'none';

    document.getElementById('victory').style.display = 'none';

    document.getElementById('levelTitle').textContent = 'ç¬¬ 1 å…³';

    document.getElementById('levelDesc').textContent = 'æ”¶é›† 10 ä¸ªé‡‘å¸';

    document.getElementById('levelInfo').style.display = 'block';

    updateUI();

}



// æŒ‰é’®äº‹ä»¶

document.getElementById('startBtn').addEventListener('click', startLevel);

document.getElementById('restartBtn').addEventListener('click', resetGame);
document.getElementById('playAgainBtn').addEventListener('click', resetGame);

// åˆå§‹åŒ–
updateUI();

// æ¸¸æˆå¾ªç¯
function gameLoop() {
update();
draw();
requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
