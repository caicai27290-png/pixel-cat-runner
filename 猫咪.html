<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê± ÂÉèÁ¥†Áå´Âí™Ë∑ëÈÖ∑</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0f;
            font-family: 'Microsoft YaHei', monospace;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 8px;
            overflow: hidden;
        }
        #gameCanvas {
            image-rendering: pixelated;
            display: block;
        }
        #ui {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
        }
        .ui-item {
            background: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .progress-bar {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #e74c3c);
            transition: width 0.3s;
        }
        #levelInfo, #gameOver, #victory {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            display: none;
            background: rgba(10,10,15,0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid;
            z-index: 100;
        }
        #levelInfo { border-color: #f1c40f; }
        #gameOver { border-color: #e74c3c; }
        #victory { border-color: #2ecc71; }
        .btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            color: #fff;
            cursor: pointer;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        #instructions {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            text-align: center;
        }
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="500"></canvas>
        <div id="ui">
            <div class="ui-item" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div class="ui-item" id="level">Á¨¨ 1 ÂÖ≥</div>
            <div class="ui-item" id="score">üí∞ 0 / 10</div>
        </div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
        
        <div id="levelInfo">
            <h2 id="levelTitle">Á¨¨ 1 ÂÖ≥</h2>
            <p id="levelDesc">Êî∂ÈõÜ 10 ‰∏™ÈáëÂ∏Å</p>
            <p style="font-size: 14px; color: #888; margin-top: 10px;">A/DÁßªÂä® | Á©∫Ê†º/ÁÇπÂáªË∑≥Ë∑É</p>
            <button class="btn" id="startBtn">ÂºÄÂßãÊ∏∏Êàè</button>
        </div>
        
        <div id="gameOver">
            <h2>üíÄ GAME OVER</h2>
<p>ÊúÄÁªàÂÖ≥Âç°: <span id="finalLevel">1</span></p>
<p>ÊÄªÈáëÂ∏Å: <span id="finalCoins">0</span></p>
<button class="btn" id="restartBtn">ÈáçÊñ∞ÂºÄÂßã</button>
</div>
    <div id="victory">
        <h2>üèÜ ÈÄöÂÖ≥ÊàêÂäü!</h2>
        <p>ÊÅ≠ÂñúÂÆåÊàêÊâÄÊúâÂÖ≥Âç°!</p>
        <p>ÊÄªÈáëÂ∏Å: <span id="totalCoins">0</span></p>
        <button class="btn" id="playAgainBtn">ÂÜçÁé©‰∏ÄÊ¨°</button>
    </div>
    
    <div id="instructions">
        <span class="key">A</span>/<span class="key">D</span> ÁßªÂä® | 
        <span class="key">Á©∫Ê†º</span> Ë∑≥Ë∑É | 
        <span class="key">ÁÇπÂáª</span> Ë∑≥Ë∑É
    </div>
</div>
// ==================== Ê∏∏ÊàèÈÖçÁΩÆ ====================
const CANVAS_WIDTH = 900;
const CANVAS_HEIGHT = 500;
const GROUND_Y = 370;

const LEVELS = [
    { id: 1, targetCoins: 10, obstacleRate: 0.015, monsterCount: 0, speed: 3 },
    { id: 2, targetCoins: 30, obstacleRate: 0.022, monsterCount: 1, speed: 3.5 },
    { id: 3, targetCoins: 50, obstacleRate: 0.028, monsterCount: 3, speed: 4 }
];

let currentLevel = 0;
let lives = 3;
let coins = 0;
let gameRunning = false;
let frameCount = 0;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.code === 'Space') { e.preventDefault(); }
});
document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }
    create(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 40, color,
                size: Math.random() * 5 + 2
            });
        }
    }
    createText(x, y, text, color) {
        this.particles.push({ x, y, text, color, vy: -2, life: 40, isText: true });
    }
    update() {
        this.particles = this.particles.filter(p => {
            p.x += p.vx || 0; p.y += p.vy || 0; p.life--;
            return p.life > 0;
        });
    }
    draw() {
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life / 40;
            if (p.isText) {
                ctx.fillStyle = p.color;
                ctx.font = 'bold 20px Arial';
                ctx.fillText(p.text, p.x, p.y);
            } else {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.globalAlpha = 1;
    }
}

const particles = new ParticleSystem();
class Cat {
    constructor() {
        this.x = 120; this.y = GROUND_Y - 50;
        this.width = 50; this.height = 50;
        this.velocityY = 0; this.grounded = true;
        this.invincible = false; this.invincibleTime = 0;
        this.shieldTime = 0; this.animFrame = 0;
    }
    jump() {
        if (this.grounded) {
            this.velocityY = -14;
            this.grounded = false;
            particles.create(this.x + 25, this.y + 50, '#fff', 5);
        }
    }
    update() {
        this.animFrame++;
        const speed = 5;
        if (keys['a'] || keys['arrowleft']) this.x = Math.max(0, this.x - speed);
        if (keys['d'] || keys['arrowright']) this.x = Math.min(CANVAS_WIDTH - this.width, this.x + speed);
        if ((keys[' '] || keys['space']) && this.grounded) this.jump();
        
        this.velocityY += 0.6;
        this.y += this.velocityY;
        if (this.y + this.height >= GROUND_Y) {
            this.y = GROUND_Y - this.height;
            this.velocityY = 0;
            this.grounded = true;
        }
        if (this.invincibleTime > 0) {
            this.invincibleTime--;
            if (this.invincibleTime <= 0) this.invincible = false;
        }
        if (this.shieldTime > 0) this.shieldTime--;
    }
    takeDamage() {
        if (this.invincible || this.shieldTime > 0) return false;
        lives--;
        this.invincible = true;
        this.invincibleTime = 90;
        particles.create(this.x + 25, this.y + 25, '#ff4757', 15);
        return true;
    }
    heal() {
        if (lives < 3) {
            lives++;
            particles.createText(this.x + 25, this.y, '+1‚ù§Ô∏è', '#2ecc71');
        }
    }
    draw() {
        if (this.invincible && Math.floor(Date.now() / 80) % 2 === 0) ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#ff8c42';
        ctx.fillRect(this.x + 10, this.y + 15, 30, 28);
        ctx.fillRect(this.x + 20, this.y - 5, 28, 24);
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(this.x + 28, this.y + 6, 6, 7, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(this.x + 42, this.y + 6, 6, 7, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath(); ctx.ellipse(this.x + 28, this.y + 7, 3.5, 4.5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(this.x + 42, this.y + 7, 3.5, 4.5, 0, 0, Math.PI * 2); ctx.fill();
        if (this.shieldTime > 0) {
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;
            ctx.strokeRect(this.x - 5, this.y - 5, 60, 60);
        }
        ctx.globalAlpha = 1;
    }
}

class Coin {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 30; this.height = 30;
        this.collected = false; this.rotation = 0;
        this.floatOffset = Math.random() * Math.PI * 2;
    }
    update() { this.x -= LEVELS[currentLevel].speed; this.rotation += 0.08; }
    draw() {
        const floatY = Math.sin(Date.now() * 0.005 + this.floatOffset) * 5;
        ctx.save();
        ctx.translate(this.x + 15, this.y + 15 + floatY);
        ctx.scale(Math.abs(Math.cos(this.rotation)), 1);
        ctx.fillStyle = '#f1c40f';
        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#f39c12';
        ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#f1c40f';
        ctx.font = 'bold 16px monospace'; ctx.textAlign = 'center';
        ctx.fillText('$', 0, 5);
        ctx.restore();
    }
}

class Spike {
    constructor(x) { this.x = x; this.y = GROUND_Y - 35; this.width = 35; this.height = 35; }
    update() { this.x -= LEVELS[currentLevel].speed; }
    draw() {
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + 35);
        ctx.lineTo(this.x + 17.5, this.y);
        ctx.lineTo(this.x + 35, this.y + 35);
        ctx.closePath(); ctx.fill();
    }
}

class Box {
constructor(x) { this.x = x; this.y = GROUND_Y - 45; this.width = 45; this.height = 45; }
update() { this.x -= LEVELS[currentLevel].speed; }
draw() {
ctx.fillStyle = '#27ae60';
ctx.fillRect(this.x, this.y, 45, 45);
ctx.fillStyle = '#1e8449';
ctx.fillRect(this.x, this.y, 45, 5);
ctx.fillRect(this.x, this.y + 40, 45, 5);
ctx.fillStyle = '#fff';
ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
ctx.fillText('‚Üë', this.x + 22.5, this.y + 30);
}
}

class Monster {
constructor(x) { this.x = x; this.y = GROUND_Y - 45; this.width = 45; this.height = 45; this.speed = 1.5; this.frame = 0; }
update() { this.x -= LEVELS[currentLevel].speed + this.speed; this.frame++; }
draw() {
const bounce = Math.sin(this.frame * 0.3) * 3;
ctx.fillStyle = '#e74c3c';
ctx.fillRect(this.x + 5, this.y + 10 + bounce, 35, 30);
ctx.fillStyle = '#fff';
ctx.fillRect(this.x + 12, this.y + 15 + bounce, 8, 8);
ctx.fillRect(this.x + 28, this.y + 15 + bounce, 8, 8);
ctx.fillStyle = '#000';
ctx.fillRect(this.x + 14, this.y + 17 + bounce, 4, 4);
ctx.fillRect(this.x + 30, this.y + 17 + bounce, 4, 4);
}
}
const cat = new Cat();
let coinArr = [];
let spikeArr = [];
let boxArr = [];
let monsterArr = [];

function spawnObjects() {
    const level = LEVELS[currentLevel];
    if (Math.random() < level.obstacleRate * 1.5) coinArr.push(new Coin(CANVAS_WIDTH, GROUND_Y - 70 - Math.random() * 100));
    if (Math.random() < level.obstacleRate * 0.6) spikeArr.push(new Spike(CANVAS_WIDTH));
    if (Math.random() < level.obstacleRate * 0.4) boxArr.push(new Box(CANVAS_WIDTH));
    if (monsterArr.length < level.monsterCount && Math.random() < 0.005) monsterArr.push(new Monster(CANVAS_WIDTH));
}

function update() {
    if (!gameRunning) return;
    frameCount++;
    cat.update();
    particles.update();
    spawnObjects();
    
    coinArr = coinArr.filter(coin => {
        coin.update();
        if (!coin.collected && checkCollision(cat, coin)) {
            coin.collected = true;
            coins++;
            particles.create(coin.x + 15, coin.y + 15, '#f1c40f', 10);
            updateUI();
            checkLevelComplete();
            return false;
        }
        return coin.x > -50;
    });
    
    spikeArr = spikeArr.filter(spike => {
        spike.update();
        if (checkCollision(cat, spike) && cat.takeDamage()) {
            if (lives <= 0) gameOver();
        }
        return spike.x > -50;
    });
    
    boxArr = boxArr.filter(box => {
        box.update();
        if (cat.velocityY > 0 && cat.x + cat.width > box.x + 5 && cat.x < box.x + 40 &&
            cat.y + cat.height >= box.y && cat.y + cat.height <= box.y + 15) {
            cat.y = box.y - cat.height;
            cat.velocityY = 0;
            cat.grounded = true;
            cat.shieldTime = 180;
        }
        return box.x > -50;
    });
    
    monsterArr = monsterArr.filter(monster => {
        monster.update();
        if (cat.velocityY > 0 && cat.x + cat.width > monster.x + 5 && cat.x < monster.x + 40 &&
            cat.y + cat.height >= monster.y && cat.y + cat.height <= monster.y + 20) {
            cat.velocityY = -10;
            cat.heal();
            particles.create(monster.x + 22, monster.y + 22, '#ff6b6b', 12);
            return false;
        } else if (checkCollision(cat, monster) && cat.takeDamage()) {
            if (lives <= 0) gameOver();
        }
        return monster.x > -100;
    });
}

function draw() {
    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    grad.addColorStop(0, '#1a1a2e');
    grad.addColorStop(1, '#16213e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
        const x = (i * 37 + frameCount * 0.1) % CANVAS_WIDTH;
        const y = (i * 23) % 300;
        ctx.globalAlpha = 0.3 + (Math.sin(frameCount * 0.05 + i) + 1) * 0.35;
        ctx.fillRect(x, y, (i % 3) + 1, (i % 3) + 1);
    }
    ctx.globalAlpha = 1;
    
    ctx.fillStyle = '#2ecc71';
    ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
    
    boxArr.forEach(b => b.draw());
    spikeArr.forEach(s => s.draw());
    coinArr.forEach(c => c.draw());
    monsterArr.forEach(m => m.draw());
    cat.draw();
    particles.draw();
}

function updateUI() {
    document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(lives);
    document.getElementById('level').textContent = `Á¨¨ ${currentLevel + 1} ÂÖ≥`;
    document.getElementById('score').textContent = `üí∞ ${coins} / ${LEVELS[currentLevel].targetCoins}`;
    document.getElementById('progressFill').style.width = `${(coins / LEVELS[currentLevel].targetCoins) * 100}%`;
}

function checkLevelComplete() {
    if (coins >= LEVELS[currentLevel].targetCoins) {
        if (currentLevel < LEVELS.length - 1) nextLevel();
        else victory();
    }
}

function nextLevel() {
    gameRunning = false;
    currentLevel++;
    coins = 0;
    lives = 3;
    cat.x = 120; cat.y = GROUND_Y - 50;
    cat.velocityY = 0; cat.grounded = true;
cat.invincible = false; cat.invincibleTime = 0; cat.shieldTime = 0;
coinArr = []; spikeArr = []; boxArr = []; monsterArr = [];
document.getElementById('levelTitle').textContent = Á¨¨ ${currentLevel + 1} ÂÖ≥;
document.getElementById('levelDesc').textContent = Êî∂ÈõÜ ${LEVELS[currentLevel].targetCoins} ‰∏™ÈáëÂ∏Å;
document.getElementById('levelInfo').style.display = 'block';
updateUI();
}

function gameOver() {
gameRunning = false;
document.getElementById('finalLevel').textContent = currentLevel + 1;
document.getElementById('finalCoins').textContent = coins;
document.getElementById('gameOver').style.display = 'block';
}

function victory() {
gameRunning = false;
document.getElementById('totalCoins').textContent = coins;
document.getElementById('victory').style.display = 'block';
}

document.getElementById('startBtn').addEventListener('click', () => {
document.getElementById('levelInfo').style.display = 'none';
gameRunning = true;
});
document.getElementById('restartBtn').addEventListener('click', () => {
currentLevel = 0; lives = 3; coins = 0;
cat.x = 120; cat.y = GROUND_Y - 50;
cat.velocityY = 0; cat.grounded = true;
cat.invincible = false; cat.invincibleTime = 0; cat.shieldTime = 0;
coinArr = []; spikeArr = []; boxArr = []; monsterArr = [];
document.getElementById('gameOver').style.display = 'none';
document.getElementById('levelTitle').textContent = 'Á¨¨ 1 ÂÖ≥';
document.getElementById('levelDesc').textContent = 'Êî∂ÈõÜ 10 ‰∏™ÈáëÂ∏Å';
document.getElementById('levelInfo').style.display = 'block';
updateUI();
});
document.getElementById('playAgainBtn').addEventListener('click', () => {
document.getElementById('victory').style.display = 'none';
document.getElementById('restartBtn').click();
});

canvas.addEventListener('click', () => cat.jump());
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); cat.jump(); });

updateUI();
function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
gameLoop();
</script>
</body>
</html>
